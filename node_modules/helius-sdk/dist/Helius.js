"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helius = void 0;
const axios_1 = __importDefault(require("axios"));
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
const RpcClient_1 = require("./RpcClient");
const API_URL_V0 = "https://api.helius.xyz/v0";
const API_URL_V1 = "https://api.helius.xyz/v1";
/**
 * This is the base level class for interfacing with all Helius API methods.
 * @class
 */
class Helius {
    /**
     * Initializes Helius API client with an API key
     * @constructor
     * @param apiKey - API key generated at dev.helius.xyz
     */
    constructor(apiKey, cluster = "mainnet-beta") {
        this.apiKey = apiKey;
        this.cluster = cluster;
        this.endpoint = (0, utils_1.heliusClusterApiUrl)(apiKey, cluster);
        this.connection = new web3_js_1.Connection(this.endpoint);
        this.rpc = new RpcClient_1.RpcClient(this.connection);
    }
    /**
     * Retrieves a list of all webhooks associated with the current API key
     * @returns {Promise<Webhook[]>} a promise that resolves to an array of webhook objects
     * @throws {Error} if there is an error calling the webhooks endpoint or if the response contains an error
     */
    getAllWebhooks() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield axios_1.default.get(`${API_URL_V0}/webhooks?api-key=${this.apiKey}`);
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error calling getWebhooks: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error calling getWebhooks: ${err}`);
                }
            }
        });
    }
    /**
     * Retrieves a single webhook by its ID, associated with the current API key
     * @param {string} webhookID - the ID of the webhook to retrieve
     * @returns {Promise<Webhook>} a promise that resolves to a webhook object
     * @throws {Error} if there is an error calling the webhooks endpoint or if the response contains an error
     */
    getWebhookByID(webhookID) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield axios_1.default.get(`${API_URL_V0}/webhooks/${webhookID}?api-key=${this.apiKey}`);
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during getWebhookByID: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during getWebhookByID: ${err}`);
                }
            }
        });
    }
    /**
     * Creates a new webhook with the provided request
     * @param {CreateWebhookRequest} createWebhookRequest - the request object containing the webhook information
     * @returns {Promise<Webhook>} a promise that resolves to the created webhook object
     * @throws {Error} if there is an error calling the webhooks endpoint or if the response contains an error
     */
    createWebhook(createWebhookRequest) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield axios_1.default.post(`${API_URL_V0}/webhooks?api-key=${this.apiKey}`, Object.assign({}, createWebhookRequest));
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during createWebhook: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during createWebhook: ${err}`);
                }
            }
        });
    }
    /**
     * Deletes a webhook by its ID
     * @param {string} webhookID - the ID of the webhook to delete
     * @returns {Promise<boolean>} a promise that resolves to true if the webhook was successfully deleted, or false otherwise
     * @throws {Error} if there is an error calling the webhooks endpoint or if the response contains an error
     */
    deleteWebhook(webhookID) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield axios_1.default.delete(`${API_URL_V0}/webhooks/${webhookID}?api-key=${this.apiKey}`);
                return true;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during deleteWebhook: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during deleteWebhook: ${err}`);
                }
            }
        });
    }
    /**
     * Edits an existing webhook by its ID with the provided request
     * @param {string} webhookID - the ID of the webhook to edit
     * @param {EditWebhookRequest} editWebhookRequest - the request object containing the webhook information
     * @returns {Promise<Webhook>} a promise that resolves to the edited webhook object
     * @throws {Error} if there is an error calling the webhooks endpoint or if the response contains an error
     */
    editWebhook(webhookID, editWebhookRequest) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const webhook = yield this.getWebhookByID(webhookID);
                const editRequest = Object.assign(Object.assign({}, webhook), editWebhookRequest);
                delete editRequest["webhookID"];
                delete editRequest["wallet"];
                const { data } = yield axios_1.default.put(`${API_URL_V0}/webhooks/${webhookID}?api-key=${this.apiKey}`, editRequest);
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during editWebhook: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during editWebhook: ${err}`);
                }
            }
        });
    }
    /**
     * Appends an array of addresses to an existing webhook by its ID
     * @param {string} webhookID - the ID of the webhook to edit
     * @param {string[]} newAccountAddresses - the array of addresses to be added to the webhook
     * @returns {Promise<Webhook>} a promise that resolves to the edited webhook object
     * @throws {Error} if there is an error calling the webhooks endpoint, if the response contains an error, or if the number of addresses exceeds 10,000
     */
    appendAddressesToWebhook(webhookID, newAccountAddresses) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const webhook = yield this.getWebhookByID(webhookID);
                const accountAddresses = webhook.accountAddresses.concat(newAccountAddresses);
                webhook.accountAddresses = accountAddresses;
                if (accountAddresses.length > 100000) {
                    throw new Error(`a single webhook cannot contain more than 100,000 addresses`);
                }
                const editRequest = Object.assign({}, webhook);
                delete editRequest["webhookID"];
                delete editRequest["wallet"];
                const { data } = yield axios_1.default.put(`${API_URL_V0}/webhooks/${webhookID}?api-key=${this.apiKey}`, editRequest);
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during appendAddressesToWebhook: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during appendAddressesToWebhook: ${err}`);
                }
            }
        });
    }
    createCollectionWebhook(request) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((request === null || request === void 0 ? void 0 : request.collectionQuery) == undefined) {
                throw new Error(`must provide collectionQuery object.`);
            }
            const { firstVerifiedCreators, verifiedCollectionAddresses } = request.collectionQuery;
            if (firstVerifiedCreators != undefined &&
                verifiedCollectionAddresses != undefined) {
                throw new Error(`cannot provide both firstVerifiedCreators and verifiedCollectionAddresses. Please only provide one.`);
            }
            let mintlist = [];
            let query = {};
            if (firstVerifiedCreators != undefined) {
                query = { firstVerifiedCreators };
            }
            else {
                // must have used verifiedCollectionAddresses
                query = { verifiedCollectionAddresses };
            }
            try {
                let mints = yield this.getMintlist({
                    query,
                    options: {
                        limit: 10000,
                    },
                });
                mintlist.push(...mints.result);
                while (mints.paginationToken) {
                    mints = yield this.getMintlist({
                        query,
                        options: {
                            limit: 10000,
                            paginationToken: mints.paginationToken,
                        },
                    });
                    mintlist.push(...mints.result);
                }
                const { webhookURL, transactionTypes, authHeader, webhookType } = request;
                const payload = {
                    webhookURL,
                    accountAddresses: mintlist.map((x) => x.mint),
                    transactionTypes,
                };
                if (authHeader) {
                    payload["authHeader"] = authHeader;
                }
                if (webhookType) {
                    payload["webhookType"] = webhookType;
                }
                return yield this.createWebhook(Object.assign({}, payload));
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during createCollectionWebhook: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during createCollectionWebhook: ${err}`);
                }
            }
        });
    }
    getMintlist(request) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((request === null || request === void 0 ? void 0 : request.query) == undefined) {
                throw new Error(`must provide query object.`);
            }
            const { firstVerifiedCreators, verifiedCollectionAddresses } = request.query;
            if (firstVerifiedCreators != undefined &&
                verifiedCollectionAddresses != undefined) {
                throw new Error(`cannot provide both firstVerifiedCreators and verifiedCollectionAddresses. Please only provide one.`);
            }
            try {
                const { data } = yield axios_1.default.post(`${API_URL_V1}/mintlist?api-key=${this.apiKey}`, Object.assign({}, request));
                return data;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    throw new Error(`error during getMintlist: ${((_a = err.response) === null || _a === void 0 ? void 0 : _a.data.error) || err}`);
                }
                else {
                    throw new Error(`error during getMintlist: ${err}`);
                }
            }
        });
    }
}
exports.Helius = Helius;
