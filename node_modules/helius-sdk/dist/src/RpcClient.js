"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const web3_js_1 = require("@solana/web3.js");
class RpcClient {
    constructor(connection) {
        this.connection = connection;
    }
    /**
     * Request an allocation of lamports to the specified address
     * @returns {Promise<SendAndConfirmTransactionResponse>}
     */
    airdrop(publicKey, lamports, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.connection.requestAirdrop(publicKey, lamports);
            const blockhashWithExpiryBlockHeight = yield this.getLatestBlockhash();
            const confirmResponse = yield this.connection.confirmTransaction(Object.assign({ signature }, blockhashWithExpiryBlockHeight), commitment);
            return Object.assign({ signature, confirmResponse }, blockhashWithExpiryBlockHeight);
        });
    }
    /**
     * Fetch the latest blockhash from the cluster
     * @returns {Promise<BlockhashWithExpiryBlockHeight>}
     */
    getLatestBlockhash(commitmentOrConfig = "finalized") {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.getLatestBlockhash(commitmentOrConfig);
        });
    }
    /**
     * Returns the current transactions per second (TPS) rate â€” including voting transactions.
     *
     * @returns {Promise<number>} A promise that resolves to the current TPS rate.
     * @throws {Error} If there was an error calling the `getRecentPerformanceSamples` method.
     */
    getCurrentTPS() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const samples = yield this.connection.getRecentPerformanceSamples(1);
                return ((_a = samples[0]) === null || _a === void 0 ? void 0 : _a.numTransactions) / ((_b = samples[0]) === null || _b === void 0 ? void 0 : _b.samplePeriodSecs);
            }
            catch (e) {
                throw new Error(`error calling getCurrentTPS: ${e}`);
            }
        });
    }
    /**
     * Returns all the stake accounts for a given public key
     *
     * @returns {Promise<number>} A promise that resolves to the current TPS rate.
     * @throws {Error} If there was an error calling the `getStakeAccounts` method.
     */
    getStakeAccounts(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.connection.getParsedProgramAccounts(new web3_js_1.PublicKey('Stake11111111111111111111111111111111111111'), {
                    filters: [
                        {
                            dataSize: 200
                        },
                        {
                            memcmp: {
                                offset: 44,
                                bytes: wallet
                            },
                        },
                    ],
                });
            }
            catch (e) {
                throw new Error(`error calling getStakeAccounts: ${e}`);
            }
        });
    }
    /**
       * Returns all the token accounts for a given mint address (ONLY FOR SPL TOKENS)
       *
       * @returns {Promise<{pubkey: PublicKey; account: AccountInfo<ParsedAccountData | Buffer}[]>} A promise that resolves to an array of accountInfo
       * @throws {Error} If there was an error calling the `getTokenHolders` method.
       */
    getTokenHolders(mintAddress) {
        try {
            return this.connection.getParsedProgramAccounts(new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), {
                filters: [
                    {
                        dataSize: 165
                    },
                    {
                        memcmp: {
                            offset: 0,
                            bytes: mintAddress
                        }
                    }
                ]
            });
        }
        catch (e) {
            throw new Error(`error calling getTokenHolders: ${e}`);
        }
    }
}
exports.RpcClient = RpcClient;
